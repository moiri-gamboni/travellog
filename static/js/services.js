// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var srv;

  srv = angular.module("mainModule.services", []);

  srv.factory('Map', [
    '$http', '$rootScope', function($http, $rootScope) {
      var factory;
      factory = {
        data: {
          logs: {},
          latLogs: [],
          lngLogs: [],
          current: null,
          loadingLogs: 0
        },
        getCurrentLog: function() {
          console.log('get current log');
          if ((factory.data.current != null) && (factory.data.lngLogs != null) && (factory.data.lngLogs[factory.data.current[0]] != null)) {
            return factory.data.logs[factory.data.lngLogs[factory.data.current[0]].id];
          } else {
            return null;
          }
        },
        getLogs: function(success) {
          var get;
          return get = $http.get(window.location.protocol + "//" + window.location.host + "/logs").success(success).error(function(data, status, headers, config) {
            console.log('getLogs error');
            return console.log(data);
          });
        },
        move: function(direction) {
          var change, newCurrentLog;
          console.log('move');
          change = direction === 'N' || direction === 'E' ? +1 : -1;
          if (direction === 'N' || direction === 'S') {
            newCurrentLog = factory.data.logs[factory.data.latLogs[mod(factory.data.current[1] + change, factory.data.latLogs.length)].id];
          } else {
            newCurrentLog = factory.data.logs[factory.data.lngLogs[mod(factory.data.current[0] + change, factory.data.latLogs.length)].id];
          }
          factory.getClosestLogs(newCurrentLog.key);
          factory.data.current = newCurrentLog.key;
          console.log('move done');
          return newCurrentLog;
        },
        getLog: function(logId, callback) {
          var get;
          console.log('get log');
          if (factory.data.logs[logId].body == null) {
            console.log('has no body');
            factory.data.loadingLogs++;
            $rootScope.$broadcast('is-loading-log', true);
            get = $http.get(window.location.protocol + "//" + window.location.host + "/logs", {
              params: {
                id: logId
              }
            });
            if (callback != null) {
              return get.success(function(data, status, headers, config) {
                console.log('get log success');
                factory.data.loadingLogs--;
                callback(data, status, headers, config);
                if (factory.data.loadingLogs === 0) {
                  return $rootScope.$broadcast('is-loading-log', false);
                }
              }).error(function(data, status, headers, config) {
                console.log('get log error');
                console.log(data);
                factory.data.loadingLogs--;
                if (factory.data.loadingLogs === 0) {
                  return $rootScope.$broadcast('is-loading-log', false);
                }
              });
            } else {
              return get.success(function(data, status, headers, config) {
                console.log('get log success');
                console.log(data.log);
                factory.data.loadingLogs--;
                factory.data.logs[data.log.id].title = data.log.title;
                factory.data.logs[data.log.id].profileId = data.log.profileId;
                factory.data.logs[data.log.id].profileName = data.log.profileName;
                factory.data.logs[data.log.id].body = data.log.body;
                if (factory.data.loadingLogs === 0) {
                  return $rootScope.$broadcast('is-loading-log', false);
                }
              }).error(function(data, status, headers, config) {
                console.log('get log error');
                console.log(data);
                factory.data.loadingLogs--;
                if (factory.data.loadingLogs === 0) {
                  return $rootScope.$broadcast('is-loading-log', false);
                }
              });
            }
          }
        },
        getClosestLogs: function(around) {
          var direction, location, _i, _len, _ref, _results;
          console.log('get get closests logs');
          _ref = ['N', 'E', 'S', 'W'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            direction = _ref[_i];
            location = factory.getClosestLocation(around, direction);
            _results.push(factory.getLog(factory.data.lngLogs[location[0]].id));
          }
          return _results;
        },
        getClosestLocation: function(from, direction) {
          var breakLoop, change, i, tempKey, tempLog, wrapNumber, _i, _len, _ref;
          tempKey = from.slice();
          change = direction === 'N' || direction === 'E' ? 1 : -1.;
          breakLoop = false;
          _ref = [0, 1, 2];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            wrapNumber = _ref[_i];
            if (breakLoop) {
              break;
            }
            if (direction === 'N' || direction === 'S') {
              i = Math.abs(mod(from[1] + change, factory.data.latLogs.length));
              while (i !== from[1]) {
                tempKey[1] = i;
                tempLog = factory.data.latLogs[tempKey[1]];
                tempKey = factory.data.logs[tempLog.id].key;
                return tempKey;
                if (factory.inRange(from, tempKey, direction, wrapNumber)) {
                  breakLoop = true;
                  break;
                }
                i = Math.abs(mod(i + change, factory.data.latLogs.length));
              }
            } else {
              i = Math.abs(mod(from[0] + change, factory.data.lngLogs.length));
              while (i !== from[0]) {
                tempKey[0] = i;
                tempLog = factory.data.lngLogs[tempKey[0]];
                tempKey = factory.data.logs[tempLog.id].key;
                return tempKey;
                if (factory.inRange(from, tempKey, direction, wrapNumber)) {
                  breakLoop = true;
                  break;
                }
                i = Math.abs(mod(i + change, factory.data.lngLogs.length));
              }
            }
          }
          return tempKey;
        },
        inRange: function(from, to, direction, wrapNumber) {
          var gradient, wrapDirection;
          from = factory.data.lngLogs[from[0]];
          to = factory.data.lngLogs[to[0]];
          wrapDirection = direction === 'N' || direction === 'E' ? 1 : -1;
          gradient = ((to.lat + wrapDirection * wrapNumber * 90) - from.lat) / ((to.lng + wrapDirection * wrapNumber * 180) - from.lng);
          if (direction === 'N' || direction === 'S') {
            if (gradient <= -0.5 || gradient >= 0.5) {
              if (direction === 'N') {
                return to.lat >= from.lat;
              } else {
                return to.lat <= from.lat;
              }
            } else {
              return false;
            }
          } else {
            if (gradient >= -0.5 && gradient <= 0.5) {
              if (direction === 'E') {
                return to.lng >= from.lng;
              } else {
                return to.lng <= from.lng;
              }
            } else {
              return false;
            }
          }
        },
        initMap: function() {
          var getLogsCallback;
          getLogsCallback = function(mapData) {
            return function(data, status, headers, config) {
              var i, id, keys, log, _i, _j, _len, _len1, _ref, _ref1;
              console.log('get logs success');
              $rootScope.$broadcast('logs-ready');
              mapData.latLogs = data.logs.slice().sort(function(b, a) {
                return b.lat - a.lat;
              });
              console.log('sort lats');
              _ref = mapData.latLogs;
              for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                log = _ref[i];
                mapData.logs[log.id] = {
                  id: log.id,
                  body: null,
                  title: null,
                  profileId: null,
                  profileName: null,
                  lat: log.lat,
                  lng: log.lng,
                  key: [null, i]
                };
              }
              console.log('build logs data');
              mapData.lngLogs = data.logs.slice().sort(function(b, a) {
                return b.lng - a.lng;
              });
              console.log('sort lngs');
              _ref1 = mapData.lngLogs;
              for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                log = _ref1[i];
                mapData.logs[log.id].key = [i, mapData.logs[log.id].key[1]];
              }
              console.log('rebuild logs data');
              keys = Object.keys(mapData.logs);
              mapData.current = mapData.logs[keys[(Math.random() * keys.length) >> 0]].key;
              id = mapData.lngLogs[factory.data.current[0]].id;
              factory.getLog(id, function(data, status, headers, config) {
                console.log('get first log success');
                factory.data.logs[data.log.id].title = data.log.title;
                factory.data.logs[data.log.id].profileId = data.log.profileId;
                factory.data.logs[data.log.id].profileName = data.log.profileName;
                factory.data.logs[data.log.id].body = data.log.body;
                return $rootScope.$broadcast('first-log-ready');
              });
              console.log('map init before closest logs done');
              factory.getClosestLogs(factory.data.current);
              return console.log('map init after closest logs');
            };
          };
          factory.getLogs(getLogsCallback(factory.data));
          return console.log('map init done');
        }
      };
      return factory;
    }
  ]);

  srv.factory('User', [function() {}]);

}).call(this);

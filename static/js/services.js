// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var srv;

  srv = angular.module("mainModule.services", []);

  srv.factory('Resources', [
    '$http', '$rootScope', function($http, $rootScope) {
      var factory;
      factory = {
        getRequest: function(endpoint, params) {
          var promise;
          promise = null;
          if (params != null) {
            promise = $http.get(window.location.protocol + "//" + window.location.host + endpoint, {
              params: params
            });
          } else {
            promise = $http.get(window.location.protocol + "//" + window.location.host + endpoint);
          }
          promise.error(function(data, status, headers, config) {
            console.log(data);
            return alert("Unknown Error, please try again later.");
          });
          return promise;
        },
        postRequest: function(endpoint, params) {
          var promise;
          promise = null;
          if (params != null) {
            promise = $http.post(window.location.protocol + "//" + window.location.host + endpoint, params);
          } else {
            promise = $http.post(window.location.protocol + "//" + window.location.host + endpoint);
          }
          promise.error(function(data, status, headers, config) {
            console.log(data);
            return alert("Unknown Error, please try again later.");
          });
          return promise;
        },
        deleteRequest: function(endpoint, params) {
          var promise;
          promise = null;
          if (params != null) {
            promise = $http["delete"](window.location.protocol + "//" + window.location.host + endpoint, {
              params: params
            });
          } else {
            promise = $http["delete"](window.location.protocol + "//" + window.location.host + endpoint);
          }
          promise.error(function(data, status, headers, config) {
            console.log(data);
            return alert("Unknown Error, please try again later.");
          });
          return promise;
        },
        getCountries: function() {
          return this.getRequest('/countries');
        },
        getLogs: function() {
          return this.getRequest('/logs');
        },
        getLog: function(logId) {
          return this.getRequest('/logs', {
            id: logId
          });
        },
        createLog: function(googleDriveId, lat, lng, country) {
          return $postRequest('/logs' + {
            gdriveId: googleDriveId,
            lat: lat,
            lng: lng,
            country: country
          });
        }
      };
      return factory;
    }
  ]);

  srv.factory('Map', [
    '$q', '$http', '$rootScope', 'Resources', function($q, $http, $rootScope, Resources) {
      var factory, res;
      res = Resources;
      factory = {
        logs: {},
        countries: {},
        sortedLogs: {},
        current: null,
        loadingLogs: 0,
        getCurrentLog: function() {
          if ((this.current != null) && (this.sortedLogs.lng != null) && (this.sortedLogs.lng[this.current[0]] != null)) {
            return this.logs[this.sortedLogs.lng[this.current[0]]];
          } else {
            return null;
          }
        },
        move: function(direction) {
          var change, newCurrentLog;
          change = direction === 'N' || direction === 'E' ? +1 : -1;
          if (direction === 'N' || direction === 'S') {
            newCurrentLog = this.logs[this.sortedLogs.lat[mod(this.current[1] + change, this.sortedLogs.lat.length)]];
          } else {
            newCurrentLog = this.logs[this.sortedLogs.lng[mod(this.current[0] + change, this.sortedLogs.lat.length)]];
          }
          this.current = newCurrentLog.key;
          return this.getClosestLogs(newCurrentLog.key);
        },
        getLog: function(logId) {
          var deferred;
          deferred = $q.defer();
          if (this.logs[logId].body == null) {
            this.loadingLogs++;
            $rootScope.$broadcast('getting-logs', this.loadingLogs);
            res.getLog(logId).success(function(data) {
              factory.logs[data.log.id].title = data.log.title;
              factory.logs[data.log.id].profileId = data.log.profileId;
              factory.logs[data.log.id].profileName = data.log.profileName;
              factory.logs[data.log.id].body = data.log.body;
              return deferred.resolve(factory.logs[data.log.id]);
            }).error(function(data) {
              console.log('getlog error');
              return deferred.reject({
                msg: 'getLog error',
                err: data
              });
            })["finally"](function() {
              factory.loadingLogs--;
              return $rootScope.$broadcast('getting-logs', factory.loadingLogs);
            });
            return deferred.promise;
          }
        },
        getClosestLogs: function(logKey) {
          var change, direction, location, logPromises, _i, _len, _ref;
          logPromises = [];
          _ref = ['N', 'E', 'S', 'W'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            direction = _ref[_i];
            change = direction === 'N' || direction === 'E' ? +1 : -1;
            if (direction === 'N' || direction === 'S') {
              location = this.logs[this.sortedLogs.lat[mod(logKey[1] + change, this.sortedLogs.lat.length)]];
            } else {
              location = this.logs[this.sortedLogs.lng[mod(logKey[0] + change, this.sortedLogs.lng.length)]];
            }
            logPromises.push(this.getLog(location.id));
          }
          return $q.all(logPromises);
        },
        getClosestLocation: function(from, direction) {
          var breakLoop, change, i, tempKey, tempLog, wrapNumber, _i, _len, _ref;
          tempKey = from.slice();
          change = direction === 'N' || direction === 'E' ? 1 : -1.;
          breakLoop = false;
          _ref = [0, 1, 2];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            wrapNumber = _ref[_i];
            if (breakLoop) {
              break;
            }
            if (direction === 'N' || direction === 'S') {
              i = Math.abs(mod(from[1] + change, this.sortedLogs.lat.length));
              while (i !== from[1]) {
                tempKey[1] = i;
                tempLog = this.sortedLogs.lat[tempKey[1]];
                tempKey = this.logs[tempLog.id].key;
                return tempKey;
                if (this.inRange(from, tempKey, direction, wrapNumber)) {
                  breakLoop = true;
                  break;
                }
                i = Math.abs(mod(i + change, this.sortedLogs.lat.length));
              }
            } else {
              i = Math.abs(mod(from[0] + change, this.sortedLogs.lng.length));
              while (i !== from[0]) {
                tempKey[0] = i;
                tempLog = this.sortedLogs.lng[tempKey[0]];
                tempKey = this.logs[tempLog.id].key;
                return tempKey;
                if (this.inRange(from, tempKey, direction, wrapNumber)) {
                  breakLoop = true;
                  break;
                }
                i = Math.abs(mod(i + change, this.sortedLogs.lng.length));
              }
            }
          }
          return tempKey;
        },
        inRange: function(from, to, direction, wrapNumber) {
          var gradient, wrapDirection;
          from = this.sortedLogs.lng[from[0]];
          to = this.sortedLogs.lng[to[0]];
          wrapDirection = direction === 'N' || direction === 'E' ? 1 : -1;
          gradient = ((to.lat + wrapDirection * wrapNumber * 90) - from.lat) / ((to.lng + wrapDirection * wrapNumber * 180) - from.lng);
          if (direction === 'N' || direction === 'S') {
            if (gradient <= -0.5 || gradient >= 0.5) {
              if (direction === 'N') {
                return to.lat >= from.lat;
              } else {
                return to.lat <= from.lat;
              }
            } else {
              return false;
            }
          } else {
            if (gradient >= -0.5 && gradient <= 0.5) {
              if (direction === 'E') {
                return to.lng >= from.lng;
              } else {
                return to.lng <= from.lng;
              }
            } else {
              return false;
            }
          }
        },
        initMap: function(logId) {
          var deferred;
          deferred = $q.defer();
          res.getLogs().success(function(data) {
            var i, keys, log, _i, _j, _len, _len1, _ref, _ref1;
            deferred.notify(0);
            factory.sortedLogs.lat = data.logs.slice().sort(function(b, a) {
              return b.lat - a.lat;
            });
            _ref = factory.sortedLogs.lat;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              log = _ref[i];
              factory.sortedLogs.lat[i] = log.id;
              factory.logs[log.id] = {
                id: log.id,
                body: null,
                title: null,
                profileId: null,
                profileName: null,
                lat: log.lat,
                lng: log.lng,
                key: [null, i]
              };
            }
            factory.sortedLogs.lng = data.logs.slice().sort(function(b, a) {
              return b.lng - a.lng;
            });
            _ref1 = factory.sortedLogs.lng;
            for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
              log = _ref1[i];
              factory.sortedLogs.lng[i] = log.id;
              factory.logs[log.id].key = [i, factory.logs[log.id].key[1]];
            }
            if (logId == null) {
              keys = Object.keys(factory.logs);
              factory.current = factory.logs[keys[(Math.random() * keys.length) >> 0]].key;
              logId = factory.sortedLogs.lng[factory.current[0]];
            } else {
              factory.current = factory.logs[logId].key;
            }
            return factory.getLog(logId).then(function(logdata) {
              deferred.notify(1);
              return factory.getClosestLogs(factory.current);
            }).then(function(data) {
              deferred.notify(2);
              return deferred.resolve(factory.logs);
            });
          });
          return deferred.promise;
        }
      };
      return factory;
    }
  ]);

  srv.factory('User', [function() {}]);

}).call(this);

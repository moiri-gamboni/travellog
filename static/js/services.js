// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var srv;

  srv = angular.module("mainModule.services", []);

  srv.factory('Map', [
    '$http', '$rootScope', function($http, $rootScope) {
      var factory;
      factory = {
        data: {
          logs: {},
          latLogs: [],
          lngLogs: [],
          current: null
        },
        getLogs: function(success) {
          var get;
          return get = $http.get(window.location.protocol + "//" + window.location.host + "/logs").success(success);
        },
        move: function(direction) {
          var change, changeCurrent, newCurrent;
          change = direction === 'N' || direction === 'E' ? +1 : -1;
          if (direction === 'N' || direction === 'S') {
            newCurrent = factory.data.logs[factory.data.latLogs[mod(factory.data.current[1] + change, factory.data.latLogs.length)].id].key;
          } else {
            newCurrent = factory.data.logs[factory.data.lngLogs[mod(factory.data.current[0] + change, factory.data.latLogs.length)].id].key;
          }
          getClosestLogs(newCurrent);
          changeCurrent = function(newCurrent) {
            return factory.data.current = newCurrent;
          };
          return $timeout(changeCurrent(newCurrent), 100);
        },
        getLog: function(logId) {
          var get;
          if (factory.data.logs[logId].body == null) {
            return get = $http.get(window.location.protocol + "//" + window.location.host + "/logs", {
              params: {
                id: logId
              }
            }).success(function(data, status, headers, config) {
              return factory.data.logs[data.log.id].body = data.log.body;
            });
          }
        },
        getClosestLogs: function(around) {
          var direction, location, _i, _len, _ref, _results;
          _ref = ['N', 'E', 'S', 'W'];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            direction = _ref[_i];
            location = factory.getClosestLocation(around, direction);
            _results.push(factory.getLog(factory.data.lngLogs[location[0]].id));
          }
          return _results;
        },
        getClosestLocation: function(from, direction) {
          var change, i, tempKey, tempLog, wrapNumber, _i, _len, _ref;
          tempKey = from;
          console.log(from);
          change = direction === 'N' || direction === 'E' ? 1 : -1.;
          _ref = [0, 1, 2];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            wrapNumber = _ref[_i];
            if (direction === 'N' || direction === 'S') {
              i = Math.abs(mod(from[1] + change, factory.data.latLogs.length));
              while (i !== from[1]) {
                tempKey[1] = i;
                tempLog = factory.data.latLogs[tempKey[1]];
                if (tempLog == null) {
                  console.log(tempKey[1]);
                  console.log(factory.data.latLogs);
                }
                tempKey = factory.data.logs[tempLog.id].key;
                if (factory.inRange(from, tempKey, direction, wrapNumber)) {
                  break;
                }
                if (Math.abs(mod(i + change, factory.data.latLogs.length)) >= factory.data.latLogs.length) {
                  console.log(i);
                } else {
                  i = Math.abs(mod(i + change, factory.data.latLogs.length));
                }
              }
            } else {
              i = Math.abs(mod(from[0] + change, factory.data.lngLogs.length));
              while (i !== from[0]) {
                tempKey[0] = i;
                tempLog = factory.data.lngLogs[tempKey[0]];
                if (tempLog == null) {
                  console.log(tempKey[0]);
                  console.log(factory.data.lngLogs);
                }
                tempKey = factory.data.logs[tempLog.id].key;
                if (factory.inRange(from, tempKey, direction, wrapNumber)) {
                  break;
                }
                if (Math.abs(mod(i + change, factory.data.lngLogs.length)) >= factory.data.lngLogs.length) {
                  console.log(i);
                } else {
                  i = Math.abs(mod(i + change, factory.data.lngLogs.length));
                }
              }
            }
          }
          console.log("\n");
          console.log(from);
          console.log("closest to");
          console.log(tempKey);
          console.log("in direction " + direction);
          return tempKey;
        },
        oldgetClosestLocation: function(from, direction) {
          var bestDistance, bestPoint, currentLog, currentOscillation, i, initialLog, latLogs, lngLogs, logs, searchRange, tempDistance, _results;
          bestDistance = 180;
          searchRange = 0;
          bestPoint = null;
          currentOscillation = [0, 0];
          logs = factory.data.logs;
          latLogs = factory.data.latLogs;
          lngLogs = factory.data.lngLogs;
          initialLog = latLogs[from[0]];
          _results = [];
          while (bestPoint === null || bestDistance < 2 * searchRange) {
            _results.push((function() {
              var _i, _len, _ref, _results1;
              _ref = [0, 1];
              _results1 = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                i = _ref[_i];
                _results1.push((function() {
                  var _results2;
                  _results2 = [];
                  while (true) {
                    currentOscillation[i] += i === 0 ? -1 : 1;
                    currentLog = lngLogs[currentOscillation[i]];
                    searchRange = max(searchRange, MathMath.abs(currentLog.lng - initialLog.lng));
                    tempDistance = bestDistance > tempDistance ? bestDistance = tempDistance : void 0;
                    if (searchRange === MathMath.abs(currentLog.lng - initialLog.lng)) {
                      break;
                    } else {
                      _results2.push(void 0);
                    }
                  }
                  return _results2;
                })());
              }
              return _results1;
            })());
          }
          return _results;
        },
        inRange: function(from, to, direction, wrapNumber) {
          var gradient, wrapDirection;
          from = factory.data.lngLogs[from[0]];
          to = factory.data.lngLogs[to[0]];
          wrapDirection = direction === 'N' || direction === 'E' ? 1 : -1;
          gradient = ((to.lat + wrapDirection * wrapNumber * 90) - from.lat) / ((to.lng + wrapDirection * wrapNumber * 180) - from.lng);
          if (direction === 'N' || direction === 'S') {
            if (gradient <= -0.5 || gradient >= 0.5) {
              if (direction === 'N') {
                return to.lat >= from.lat;
              } else {
                return to.lat <= from.lat;
              }
            } else {
              return false;
            }
          } else {
            if (gradient >= -0.5 && gradient <= 0.5) {
              if (direction === 'E') {
                return to.lng >= from.lng;
              } else {
                return to.lng <= from.lng;
              }
            } else {
              return false;
            }
          }
        },
        initMap: function() {
          var getLogsCallback;
          getLogsCallback = function(mapData) {
            return function(data, status, headers, config) {
              var current, i, id, keys, log, _i, _j, _len, _len1, _ref, _ref1;
              mapData.latLogs = data.logs.slice().sort(function(b, a) {
                return b.lat - a.lat;
              });
              console.log(mapData.latLogs);
              _ref = mapData.latLogs;
              for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                log = _ref[i];
                mapData.logs[log.id] = {
                  id: log.id,
                  body: null,
                  lat: log.lat,
                  lng: log.lng,
                  key: [null, i]
                };
              }
              mapData.lngLogs = data.logs.slice().sort(function(b, a) {
                return b.lng - a.lng;
              });
              console.log(mapData.lngLogs);
              _ref1 = mapData.lngLogs;
              for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                log = _ref1[i];
                mapData.logs[log.id].key = [i, mapData.logs[log.id].key[1]];
              }
              console.log(mapData.logs);
              keys = Object.keys(mapData.logs);
              current = mapData.logs[keys[(Math.random() * keys.length) >> 0]].key;
              id = mapData.lngLogs[current[0]].id;
              factory.getLog(id);
              return factory.getClosestLogs(current);
            };
          };
          return factory.getLogs(getLogsCallback(factory.data));
        }
      };
      return factory;
    }
  ]);

}).call(this);
